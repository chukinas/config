#!/bin/bash

_comoto_cli_command_usage() {
  cat <<EOF

Usage: comoto_cli path [OPTIONS] [PATH_SHORT_NAME]

Generate fully-qualified paths to common projects

Options:
  -h, --help  Print this help and exit

Path Short Names:
  comoto    $COMOTO_PROJECT_ROOT
  monorepo  $COMOTO_PROJECT_ROOT/monorepo
  ecom      $COMOTO_PROJECT_ROOT/monorepo/ecom
  redline   $COMOTO_PROJECT_ROOT/monorepo/redline
  zla       $COMOTO_PROJECT_ROOT/monorepo/zlaverse/dev

EOF
}

# TODO implement a way to add another argument to drill down into the main dir

# HELPERS FOR PRINTING OUTPUT TO USER
#######################################

local valid_args="comoto monorepo ecom redline zla"

_usage() {
  msg="Usage: $current_command <comoto|monorepo|ecom|redline|zla>"
  if [[ $1 == -e && -n $2 ]] ; then
    actual_cmd="comoto_cli path $2"
    echo -e "${msg}\n${actual_cmd}" >&2
  else
    echo $msg
  fi
}

# TODO should I retool this to set a $COMOTO_CLI_CUR_PATH ?
# TODO should `cd` depend on this?
# TODO rename _comoto_cli_path_execute
_comoto_cli_command_execute() {
  if [[ $1 =~ ^(-h|--help)$ ]] ; then
    _comoto_cli_command_usage
    return 0
  fi

  local current_command="comoto_cli path"
  local where_to=$1

  # TODO now that this is a function, these out functions are exposed...
  # TODO decouple this from my personal config script
  . $COMOTO_CLI_ROOT/lib/print "$current_command"

  if [[ $# -ne 1 ]]; then
    print_info "$usage" >&2
    return 1
  fi

  case "$where_to" in
    comoto)   target="$COMOTO_PROJECTS_DIR";;
    monorepo) target="$COMOTO_PROJECTS_DIR/monorepo";;
    ecom)     target="$COMOTO_PROJECTS_DIR/monorepo/ecom";;
    redline)  target="$COMOTO_PROJECTS_DIR/monorepo/redline";;
    zla)      target="$COMOTO_PROJECTS_DIR/monorepo/zlaverse/dev";;
    *)
      _usage -e "$@"
      return 1
  esac

  echo "$target"
}

_comoto_cli_command_completion() {
  [[ $# -gt 1 ]] && return 1
  COMPREPLY=( $(compgen -W "$valid_args" -- "$1") )
}
