#!/bin/bash

. $COMOTO_CLI_ROOT/lib/print

_comoto_cli_command_summary='Change directory to commonly-used paths like redline and ecom'
_comoto_cli_command_usage='comoto_cli cd [OPTIONS] PATH_SHORT_NAME'

_comoto_cli_command_help() {
  cat <<EOF

Options:
  -h, --help  Print this help and exit
  -p, --path  Echo the path instead of changing directory
              (Not yet implemented)

Path Short Names:
  comoto    $COMOTO_PROJECT_ROOT
  monorepo  $COMOTO_PROJECT_ROOT/monorepo
  ecom      $COMOTO_PROJECT_ROOT/monorepo/ecom
  redline   $COMOTO_PROJECT_ROOT/monorepo/redline
  zla       $COMOTO_PROJECT_ROOT/monorepo/zlaverse/dev

EOF
}

# TODO maybe there shouldn't be a 'path' command. Maybe it should be replaced with -p option in the 'cd' command
# TODO when I do that, I'll have to rework the option handling
# TODO either way, lots of repetition right now

_comoto_cli_command_completion() {
  unset _comoto_cli_command_completion
  . $COMOTO_CLI_ROOT/command/path
  _comoto_cli_command_completion $*
}

_comoto_cli_command_execute() {
  # TODO right now, 'comoto_cli cd --hel' produces a blank space, then exits. Should produce error instead

  if [[ $# -ne 1 ]]; then
    print_usage_error
    return 1
  fi

  local where_to=$1

  # TODO can this be used in an if so I don't have to do the `test
  path=$(comoto_cli path $where_to 2>/dev/null)
  # TODO DRY out usage. I don't want to have to add the target both here and there
  [[ $? -ne 0 ]] && print_usage_error && exit 1

  # TODO handle for incorrect targets
  print_and_eval_command "cd $(comoto_cli path $where_to)"
}
